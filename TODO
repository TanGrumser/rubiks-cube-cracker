Update CMakeList to release and remove -g.

IDDFS indexes goals, and the type is static casted to a RubiksCubeModel.  Same
with goal.isSatisfied.  The goals need to be refactored to take RubiksCubes.

Search for static_cast<RubiksCube&> and get rid of it.

Refactor MoveStores to move any type of RubikCube.
Change RubiksCubeModel::MOVE to RubksCube::MOVE.
Remove bounds checks in MoveStore.cpp#getMove.

In the new IDA searcher, there could be a better solution after the goal is
satisfied.  Probably need to keep searching the current bound until complete.

In the IDA searcher a copy of the cube could be avoided (from successors to the
node stack) by using a buffer area or dynamic memory of some sort.

If KorfSolver is reverted, remember to inflate!

In IDA*, keep a set of seen cube states and check it when making the successor queue.
IDDFS could use this set, too.

Git rid of depth in IDDFS searcher.  Use moves.size().

IDDFS and IDA* should call index.

Try Thistlethwaite with the IDA* searcher and the Korf databases.  To do so,
though, the assumption that the heuristic will return 0 will have to be
removed.

There are some typos in the comments in the searchers (acieve and cust).

Try solving the scramble with 1 move F.  The solution is F F2, and that should
be simplified to F'.

There's a pattern database (GoalG3_Permate_Corners) that could be refactored to
use the new CornerPatternDatabase class.  As part of that get rid of the
corner_perms.txt file.

Try to solve the cube outright, then bail at depth 10.
